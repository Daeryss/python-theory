#                                   S_E_T
#       Множества - набор неизменяемых объектов без определенного порядка.
#       Множества изменяемы и задаются либо {...}, либо set(...).
#       В множества не могут входить списки и другие множества, за исключением
#       неизменяемых множеств (frozen(...)). Потому что у изменяемых объектов
#       нельзя вычислить хэш. Объекты в множестве не повторяются, если вложить
#       в множество два одинаковых объекта, при выводе останется один.
#       Множеством может быть любой итерируемый объект.
a = list('aabcabd')
print('1.   a =', a)
print('     set(a) = ', set(a))
print('     sorted(list(set(a))) = ', sorted(list(set(a))),
      '\n\t\t\t- операция для упорядоченного вывода')
b = {1, 3.12, 'abc', (4, 't')}
print('2.   b =', b)
x = (3, 1, 2)
y = (1, 3, 2)
print('3.   x = ', x, '; y = ', y, sep='')
print('     is set(x) == set(y):', set(x) == set(y))
print('4.   [str(b)] = ', [str(b)],
      '\n\t\t\t - str превращает все в строку, включая скобки "{}"')

#                       О_П_Е_Р_А_Ц_И_И С М_Н_О_Ж_Е_С_Т_В_А_М_И
#     Нельзя писать пустые множетва {}. Добавить элемент в множество можно
#     командой add, если элемент уже был там, множество не изменится.
#     перебрать элементы множество можно также, как любой итерируемый объект:
#     for i in mySet:
#     чтобы проверить входит ли объект А в множество Х достаточно написать:
#     "A in X", ответом будет "true" или "false". Чтобы проверить, что А не
#     лежит в множестве: "not A in X" или "A not in X"
print('5.   x = ', set(x))
print('     1 in x:', 1 in set(x))
print('     6 in x:', 6 in set(x))
#
#     Удаление элемента из множества производится одной из двух команд -
#     discard или remove. Если удаляемого элемента не было, discard ничего не
#     изменит, remove выдаст ошибку.
#
#          Операции над множествами
#     A | B - объединение множеств (A + B), повторяющиеся элементы не входят повторно
#     A & B - пересечение множеств, выдаст только одинаковые элементы
#     А - В - элементы А, не входящие в множество В
#     А ^ B - элементы не входящие в оба множества
a = {1, 2, 3, 5}
b = {1, 2, 4}
print('6.   a = ', a, ';\tb = ', b, sep='')
print('     a | b = ', a | b)
print('     a & b = ', a & b)
print('     a - b = ', a - b)
print('     a ^ b = ', a ^ b)

#     A == B - все элементы совпадают
#     A != B - есть различные элементы
#     A <= B - все элементы А входят в В или все элементы совпадают
#     A < B  - все элементы А входят в В и А != В
#
#               С_Л_О_В_А_Р_И
#     Словари по своей сути являются множествами, внутри которого лежат пары
#     ключ - значение. Вводя запрос на ключ вывод - значение.
#     Словарь можно объявить функцией dict. capital = dict()
capital = {'Russia': 'Moscow', 'Germany': 'Berlin'}
print('7.   capital = ', capital)
capital['France'] = 'Paris'
print("     capital['France'] = 'Paris' =>")
print('=>   capital = ', capital)
print('     capital["Russia"] = ', capital["Russia"])
del capital['Germany']
print("     del capital['Germany'] = ", capital)
print("     'Russia' in capital = ", 'Russia' in capital)
#     метод .items() позволяет печатать кортежи для всех ключ - значание
print('     ', end='')
for i, j in capital.items():
      print(i, j, end='; ')
print('')
print('     ', end='')
#     аналогично можно вывести так:
for i in capital:
      print(i, capital[i], end='; ')
print('')
print('8.    Подсчет через словарь:')
#     применение словаря в качестве подсчета объектов:
s = 'hello'
letter = dict()
for i in s:
      if i in letter:
            letter[i] += 1
      else:
            letter[i] = 1
for i in sorted(letter):       # функция sorted позволяет упорядосить ключи по неубыванию
      print('     ', i, letter[i])